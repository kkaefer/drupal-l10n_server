<?php
// $Id: l10n_server.module,v 1.1.2.10 2007-08-19 00:18:37 goba Exp $

/**
 * @file
 *   Extracts translatable strings from project files.
 *
 *   Tracks all translatable strings from all projects (modules
 *   and themes), centralizing the translation process. With
 *   the "Localization community" module, it is also possible to
 *   give users the opportunity to contribute, translating all
 *   strings online.
 */

/**
 * Strings with any status.
 */
define('L10N_STATUS_ALL', 0); 

/**
 * Untranslated strings only.
 */
define('L10N_STATUS_UNTRANSLATED', 1); 

/**
 * Suggested (but not approved) strings only.
 */
define('L10N_STATUS_SUGGESTED', 2); 

/**
 * Translated strings only.
 */
define('L10N_STATUS_TRANSLATED', 3); 

// = Core hooks ================================================================

/**
 * Implementation of hook_help().
 */
function l10n_server_help($section) {
  switch ($section) {
    case 'admin/settings/l10n_server':
      return '<p>'. t('The Localization server watches for new projects popping up at drupal.org, downloads the new packages and extracts translatable strings out of them. Here you can set up the limits of how these operations are performed. The <a href="@scan_link">Scan tab</a> allows you to initiate a manual scan.', array('@scan_link' => url('admin/settings/l10n_server/scan'))) . '</p>';
  }
}

/**
 * Implementation of hook_menu().
 */
function l10n_server_menu($may_cache) {
  $items = array();
  if (!$may_cache) {
    $items[] = array(
      'title' => t('Localization server'),
      'path' => 'admin/settings/l10n_server',
      'description' => t('Configure the localization server'),
      'access' => user_access('administer localization server'),
      'callback' => 'drupal_get_form',
      'callback arguments' => 'l10n_server_settings_form',
    );
    $items[] = array(
      'title' => t('Configure'),
      'path' => 'admin/settings/l10n_server/configure',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );
    $items[] = array(
      'title' => t('Scan'),
      'path' => 'admin/settings/l10n_server/scan',
      'access' => user_access('administer localization server'),
      'callback' => 'l10n_server_scan',
      'type' => MENU_LOCAL_TASK
    );
  }
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function l10n_server_perm() {
  return array('administer localization server');
}

/**
 * Implementation of hook_cron().
 */
function l10n_server_cron() {
  if (variable_get('l10n_server_cron', FALSE)) {
    l10n_server_scan(TRUE);
  }
}

// = Settings ==================================================================

/**
 * Settings form callback.
 */
function l10n_server_settings_form() {
  $form = array();
  $form['l10n_server_limit'] = array(
    '#title' => t('Number of projects to scan at once'),
    '#description' => t('How many projects to scan on a manual or a cron run.'),
    '#type' => 'select',
    '#options' => array(-1 => t('Unlimited (not recommended)'), 1 => 1) + drupal_map_assoc(range(10, 100, 10)),
    '#default_value' => variable_get('l10n_server_limit', 1),
  );
  $form['l10n_server_cron'] = array(
    '#title' => t('Scan new projects on every cron run'),
    '#type' => 'radios',
    '#options' => array(t('Disabled'), t('Enabled')),
    '#default_value' => variable_get('l10n_server_cron', 0),
  );
  return system_settings_form($form);
}

// = Project handling ==========================================================

/**
 * Scans files of a project and release picked.
 *
 * @param $automated
 *   Whether the execution was automated and user feedback should
 *   not be provided.
 *
 * @todo
 *   Do less HTTP queries!
 */
function l10n_server_scan($automated = FALSE) {
  include_once 'l10n_server_projects.inc';
  
  // Always update full project list.
  l10n_server_sync_projects();
  
  // Pick the project we did not update for the longest period.
  $uri = db_result(db_query_range("SELECT uri FROM {l10n_server_project} ORDER BY last_parsed ASC", 0, 1));
  $project = l10n_server_get_projects($uri);
  l10n_server_sync_releases($project);
  
  // Pick the release we did not update for the longest period.
  $release = db_fetch_object(db_query_range("SELECT r.* FROM {l10n_server_project} p LEFT JOIN {l10n_server_release} r ON p.pid = r.pid WHERE p.uri = '%s' ORDER BY r.last_parsed ASC", $uri, 0, 1));
  $result = l10n_server_sync_files($release);
  
  if (!$automated) {
    // User feedback if not automated. Log messages are already done.
    if (isset($result['error'])) {
      drupal_set_message($result['error'], 'error');
    }
    if (isset($result['message'])) {
      drupal_set_message($result['message']);
    }
  }
  // Ensure that a Drupal page will be displayed with the messages.
  return '';
}

// = API functions =============================================================

/**
 * Provides a list of projects already recoreded in the l10n_server
 * database, ordered by uri.
 *
 * @param $uri
 *   Project URI, if requesting information about one project only.
 * @param $pager
 *  Number of projects to return a pager query result with. If NULL,
 *  all projects are returned.
 *  
 * @return
 *  An associative array keyed with project uris.
 */
function l10n_server_get_projects($uri = NULL, $pager = NULL) {
  static $projects = array();
  
  if (isset($pager)) {
    // If a pager view was asked, collect data independently.
    $results = pager_query('SELECT * FROM {l10n_server_project} ORDER BY uri', $pager, 0, NULL);
    $pager_results = array();
    while ($project = db_fetch_object($results)) {
      $project->core_compatibility = unserialize($project->core_compatibility);
      $pager_results[$project->uri] = $project;
      $projects[$project->uri] = $project;
    }
    return $pager_results;
  }
  else {
    if (isset($uri)) {
      // A specific project was asked for.
      if (isset($projects[$uri])) {
        // Can be served from the local cache.
        return $projects[$uri];
      }
      // Not found in cache, so query and cache before returning.
      $result = db_query("SELECT * FROM {l10n_server_project} WHERE uri = '%s'", $uri);
      if ($project = db_fetch_object($result)) {
        $project->core_compatibility = unserialize($project->core_compatibility);
        $projects[$uri] = $project;
        return $project;
      }
    }
    else {
      // A list of all projects was asked for.
      $results = db_query('SELECT * FROM {l10n_server_project} ORDER BY uri');
      while ($project = db_fetch_object($results)) {
        $project->core_compatibility = unserialize($project->core_compatibility);
        $projects[$project->uri] = $project;
      }
      return $projects;
    }
  }
}

/**
 * Get all releases of a project.
 *
 * @param $uri
 *   Project code to look up releases for.
 * @param $parsed_only
 *   TRUE or FALSE depending on whether to return already
 *   parsed (translatable) releases.
 * @return
 *   Array of release objects for project.
 */
function l10n_server_get_releases($uri = NULL, $parsed_only = TRUE) {
  $releases = array();
  $query = "SELECT r.* FROM {l10n_server_release} r LEFT JOIN {l10n_server_project} p ON r.pid = p.pid WHERE p.uri = '%s'";
  if ($parsed_only) {
    $query .= ' AND r.last_parsed > 0';
  }
  $result = db_query($query, $uri);
  while ($release = db_fetch_object($result)) {
    $releases[$release->rid] = $release;
  }
  return $releases;
}

/**
 * Get strings under some conditions.
 *
 * @param $pid
 *   Project ID to look up strings for.
 * @param $langcode
 *   Language code to use for the lookup.
 * @param $status
 *   Filter strings by status. See L10N_STATUS_ALL,
 *   L10N_STATUS_UNTRANSLATED, L10N_STATUS_SUGGESTED and
 *   L10N_STATUS_TRANSLATED.
 * @param $release
 *   Release id of the particular project release to filter with.
 *   Use NULL to not filter on releases.
 * @param $search
 *   Substring to search for in all source and translation strings.
 * @param $pager
 *   Number of strings to be returned in a pager. Should be NULL if
 *   no pager should be used.
 * @param $count
 *   Boolean indicator to return the result count (TRUE) or the result
 *   itself (FALSE). If TRUE, $pager is not considered, and only a number
 *   is returned.
 * @return
 *   An array of strings columns from database.
 */
function l10n_server_get_strings($project, $langcode, $status = L10N_STATUS_ALL, $release = NULL, $search = NULL, $pager = NULL, $count = FALSE) {
  
  $sql = $sql_count = '';
  $sql_args = array();
  
  // Project *and* language based filtering.
  $sql = "SELECT DISTINCT s.sid, s.value, s.plural, t.tid, t.translation, t.uid, t.changed FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid LEFT JOIN {l10n_server_translation} t ON s.sid = t.sid AND t.language = '%s' WHERE r.pid = %d";
  $sql_count = "SELECT COUNT(DISTINCT(s.sid)) FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid LEFT JOIN {l10n_server_translation} t ON s.sid = t.sid AND t.language = '%s' WHERE r.pid = %d";
  $sql_args = array($langcode, $project->pid);

  if (!empty($search)) {
    // Search in the source or target strings.
    $sql_args[] = $search;
    $sql_args[] = $search;
    $search_sql = " AND (s.value LIKE '%%%s%%' OR t.translation LIKE '%%%s%%')";
    $sql .= $search_sql;
    $sql_count .= $search_sql;
  }

  if (isset($release)) {
    // Release restriction.
    $sql_args[] = $release;
    $sql_args[] = $release;
    $release_sql = ' AND r.rid = %d';
    $sql .= $release_sql;
    $sql_count .= $release_sql;
  }
    
  // Restriction based on string status
  switch ($status) {
    case L10N_STATUS_UNTRANSLATED:
      $status_sql = " AND (t.translation IS NULL OR t.translation = '')";
      $sql .= $status_sql;
      $sql_count .= $status_sql;
      break;
    case L10N_STATUS_TRANSLATED:
    case L10N_STATUS_SUGGESTED:
      $status_sql = " AND t.translation != ''";
      $sql .= $status_sql;
      $sql_count .= $status_sql;
      break;
    case L10N_STATUS_ALL:
    default:
      // leave query alone.
      break;
  }

  if ($count && $sql_count) {
    // If a count is required, only run the count query.
    return db_result(db_query($sql_count, $sql_args));
  }
  elseif ($sql) {
    // Otherwise we either need a pager or a full result.
    if (isset($pager)) {
      $strings = pager_query($sql, $pager, 0, $sql_count, $sql_args);
    }
    else {
      $strings = db_query($sql, $sql_args);
    }
    $result = array();
    while ($string = db_fetch_object($strings)) {
      $result[] = $string;
    }
    return $result;
  }
}

/**
 * Get string counts for summaries.
 *
 * @param $type
 *   Type of string count to return:
 *     - all: a count of all strings
 *     - project: a count of strings in a project (identified by $id)
 *     - languages: an array of the count of translated strings by langcode
 *     - projects: an array of the count of translated strings by pid
 * @param $id
 *   The result set can be restricted by an ID from the oppposing type. Eg.
 *   'projects' summaries can be restricted to one specific language, or
 *   'languages' summeries can be restricted to one specific project. This
 *   id represents the identifier (pid or langcode) of the restricting item.
 *
 * @todo
 *   These queries are *slooow*. The query cache helps a lot with caching the
 *   result, so the slowness only shows for the first run, but still it would
 *   be good to look into optimizing these.
 */
function l10n_server_get_string_count($type, $id = NULL) {
  switch ($type) {
    case 'all':
      // Return a count of all strings.
      return db_result(db_query("SELECT COUNT(sid) FROM {l10n_server_string}"));
    
    case 'project':
      // Return a count of all strings in this project.
      return db_result(db_query('SELECT COUNT(DISTINCT s.sid) FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid WHERE r.pid = %d', $id));
    
    case 'languages':
      $sums = array();
      if (!isset($id)) {
        // Simple count query if we are not filtering by project.
        $count_sql = 'SELECT COUNT(t.sid) translation_count, t.language FROM {l10n_server_string} s LEFT JOIN {l10n_server_translation} t ON s.sid = t.sid GROUP BY t.language';
      }
      else {
        // Rather complex join if we also need to factor the project in.
        $count_sql = 'SELECT COUNT(DISTINCT t.sid) translation_count, t.language FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid LEFT JOIN {l10n_server_translation} t ON s.sid = t.sid WHERE r.pid = %d GROUP BY t.language';
      }
      $result = db_query($count_sql, $id);
      while ($row = db_fetch_object($result)) {
        $sums[$row->language] = $row->translation_count;
      }
      return $sums;
      break;
    
    case 'projects':
      $sums = $count_args = array();
      $count_sql = 'SELECT COUNT(DISTINCT t.sid) translation_count, r.pid FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid LEFT JOIN {l10n_server_translation} t ON s.sid = t.sid ';
      if (isset($id)) {
        $count_sql .= "WHERE t.language = '%s' ";
        $count_args[] = $id;
      }
      $count_sql .= 'GROUP BY r.pid';
      $result = db_query($count_sql, $count_args);
      while ($row = db_fetch_object($result)) {
        $sums[$row->pid] = $row->translation_count;
      }
      $result = db_query("SELECT COUNT(DISTINCT s.sid) string_count, r.pid FROM {l10n_server_release} r INNER JOIN {l10n_server_file} f ON r.rid = f.rid INNER JOIN {l10n_server_line} l ON f.fid = l.fid INNER JOIN {l10n_server_string} s ON l.sid = s.sid GROUP BY r.pid;");
      while ($row = db_fetch_object($result)) {
        $sums[$row->pid] = array($row->string_count, $sums[$row->pid]);
      }
      return $sums;
  }
}
